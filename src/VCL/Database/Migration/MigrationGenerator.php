<?php
/**
 * This file is part of the VCL for PHP project
 *
 * Copyright (c) 2004-2008 qadram software S.L.
 * Copyright (c) 2024-2025 Gunnar Beushausen
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 */

declare(strict_types=1);

namespace VCL\Database\Migration;

use Doctrine\DBAL\Connection as DBALConnection;
use Doctrine\DBAL\Schema\Schema;
use Doctrine\DBAL\Schema\Table;
use Doctrine\DBAL\Schema\Column;
use VCL\Database\Connection;

/**
 * MigrationGenerator generates migration files.
 *
 * This class can generate migration files in several ways:
 * - Empty migration template
 * - Diff-based migration from schema comparison
 * - Migration from a target schema definition
 *
 * Example:
 * ```php
 * $generator = new MigrationGenerator($connection, [
 *     'migrations_path' => __DIR__ . '/migrations',
 *     'migrations_namespace' => 'App\\Migrations',
 * ]);
 *
 * // Generate empty migration
 * $file = $generator->Generate('CreateUsersTable');
 *
 * // Generate diff-based migration
 * $file = $generator->GenerateDiff($targetSchema);
 * ```
 */
class MigrationGenerator
{
    protected DBALConnection $connection;
    protected string $migrationsPath;
    protected string $migrationsNamespace;

    public function __construct(Connection|DBALConnection $connection, array $config = [])
    {
        if ($connection instanceof Connection) {
            $connection->Open();
            $this->connection = $connection->Dbal();
        } else {
            $this->connection = $connection;
        }

        $this->migrationsPath = $config['migrations_path'] ?? getcwd() . '/migrations';
        $this->migrationsNamespace = $config['migrations_namespace'] ?? 'VCL\\Migrations';
    }

    /**
     * Generate a new empty migration file.
     *
     * @param string $name Descriptive name for the migration
     * @return string Path to the generated file
     */
    public function Generate(string $name): string
    {
        $version = $this->GenerateVersion($name);
        $className = $version;

        $content = $this->GenerateMigrationTemplate($className, '', '');

        return $this->WriteFile($version, $content);
    }

    /**
     * Generate a migration based on the difference between current and target schema.
     *
     * @param Schema $targetSchema The target schema to migrate to
     * @param string $name Optional descriptive name
     * @return string Path to the generated file
     */
    public function GenerateDiff(Schema $targetSchema, string $name = ''): string
    {
        $schemaManager = $this->connection->createSchemaManager();
        $currentSchema = $schemaManager->introspectSchema();

        $comparator = $schemaManager->createComparator();
        $diff = $comparator->compareSchemas($currentSchema, $targetSchema);

        if ($diff->isEmpty()) {
            throw new MigrationException("No schema changes detected");
        }

        $upCode = $this->GenerateSchemaCode($currentSchema, $targetSchema);
        $downCode = $this->GenerateSchemaCode($targetSchema, $currentSchema);

        $version = $this->GenerateVersion($name ?: 'AutoGenerated');
        $content = $this->GenerateMigrationTemplate($version, $upCode, $downCode);

        return $this->WriteFile($version, $content);
    }

    /**
     * Generate a migration from SQL statements.
     *
     * @param array $upSql SQL statements for up migration
     * @param array $downSql SQL statements for down migration
     * @param string $name Descriptive name
     * @return string Path to the generated file
     */
    public function GenerateFromSql(array $upSql, array $downSql = [], string $name = ''): string
    {
        $upCode = '';
        foreach ($upSql as $sql) {
            $escapedSql = str_replace("'", "\\'", $sql);
            $upCode .= "        \$this->AddSql('{$escapedSql}');\n";
        }

        $downCode = '';
        foreach ($downSql as $sql) {
            $escapedSql = str_replace("'", "\\'", $sql);
            $downCode .= "        \$this->AddSql('{$escapedSql}');\n";
        }

        $version = $this->GenerateVersion($name ?: 'SqlMigration');
        $content = $this->GenerateMigrationTemplate($version, $upCode, $downCode);

        return $this->WriteFile($version, $content);
    }

    /**
     * Generate a table creation migration.
     */
    public function GenerateCreateTable(
        string $tableName,
        array $columns,
        array $options = []
    ): string {
        $upCode = $this->GenerateCreateTableCode($tableName, $columns, $options);
        $downCode = "        \$schema->dropTable('{$tableName}');";

        $version = $this->GenerateVersion('Create' . $this->ToPascalCase($tableName) . 'Table');
        $content = $this->GenerateMigrationTemplate($version, $upCode, $downCode);

        return $this->WriteFile($version, $content);
    }

    /**
     * Generate code for creating a table.
     */
    protected function GenerateCreateTableCode(string $tableName, array $columns, array $options): string
    {
        $code = "        \$table = \$schema->createTable('{$tableName}');\n";

        foreach ($columns as $columnName => $columnDef) {
            $type = $columnDef['type'] ?? 'string';
            $columnOptions = $columnDef;
            unset($columnOptions['type']);

            $optionsStr = $this->ArrayToCode($columnOptions);
            $code .= "        \$table->addColumn('{$columnName}', '{$type}', {$optionsStr});\n";
        }

        // Primary key
        if (isset($options['primary'])) {
            $primaryKeys = is_array($options['primary']) ? $options['primary'] : [$options['primary']];
            $primaryStr = "['" . implode("', '", $primaryKeys) . "']";
            $code .= "        \$table->setPrimaryKey({$primaryStr});\n";
        }

        // Indexes
        if (isset($options['indexes'])) {
            foreach ($options['indexes'] as $indexName => $indexColumns) {
                $columnsStr = "['" . implode("', '", $indexColumns) . "']";
                $code .= "        \$table->addIndex({$columnsStr}, '{$indexName}');\n";
            }
        }

        // Unique indexes
        if (isset($options['unique'])) {
            foreach ($options['unique'] as $indexName => $indexColumns) {
                $columnsStr = "['" . implode("', '", $indexColumns) . "']";
                $code .= "        \$table->addUniqueIndex({$columnsStr}, '{$indexName}');\n";
            }
        }

        return $code;
    }

    /**
     * Generate schema modification code from schema diff.
     */
    protected function GenerateSchemaCode(Schema $fromSchema, Schema $toSchema): string
    {
        $code = '';

        // Tables to create
        foreach ($toSchema->getTables() as $table) {
            if (!$fromSchema->hasTable($table->getName())) {
                $code .= $this->GenerateCreateTableFromDoctrine($table);
            }
        }

        // Tables to drop
        foreach ($fromSchema->getTables() as $table) {
            if (!$toSchema->hasTable($table->getName())) {
                $code .= "        \$schema->dropTable('{$table->getName()}');\n";
            }
        }

        // Modified tables
        foreach ($toSchema->getTables() as $toTable) {
            $tableName = $toTable->getName();
            if ($fromSchema->hasTable($tableName)) {
                $fromTable = $fromSchema->getTable($tableName);
                $code .= $this->GenerateTableModificationCode($fromTable, $toTable);
            }
        }

        return $code ?: "        // No schema changes";
    }

    /**
     * Generate code to create a table from Doctrine Table object.
     */
    protected function GenerateCreateTableFromDoctrine(Table $table): string
    {
        $code = "        \$table = \$schema->createTable('{$table->getName()}');\n";

        foreach ($table->getColumns() as $column) {
            $options = $this->GetColumnOptions($column);
            $optionsStr = $this->ArrayToCode($options);
            $typeName = \Doctrine\DBAL\Types\Type::getTypeRegistry()->lookupName($column->getType());
            $code .= "        \$table->addColumn('{$column->getName()}', '{$typeName}', {$optionsStr});\n";
        }

        $primaryKey = $table->getPrimaryKey();
        if ($primaryKey !== null) {
            $columns = $primaryKey->getColumns();
            $columnsStr = "['" . implode("', '", $columns) . "']";
            $code .= "        \$table->setPrimaryKey({$columnsStr});\n";
        }

        foreach ($table->getIndexes() as $index) {
            if ($index->isPrimary()) {
                continue;
            }

            $columns = $index->getColumns();
            $columnsStr = "['" . implode("', '", $columns) . "']";

            if ($index->isUnique()) {
                $code .= "        \$table->addUniqueIndex({$columnsStr}, '{$index->getName()}');\n";
            } else {
                $code .= "        \$table->addIndex({$columnsStr}, '{$index->getName()}');\n";
            }
        }

        $code .= "\n";
        return $code;
    }

    /**
     * Generate code for table modifications.
     */
    protected function GenerateTableModificationCode(Table $fromTable, Table $toTable): string
    {
        $code = '';
        $tableName = $toTable->getName();

        // Columns to add
        foreach ($toTable->getColumns() as $column) {
            if (!$fromTable->hasColumn($column->getName())) {
                $options = $this->GetColumnOptions($column);
                $optionsStr = $this->ArrayToCode($options);
                $typeName = \Doctrine\DBAL\Types\Type::getTypeRegistry()->lookupName($column->getType());
                $code .= "        \$schema->getTable('{$tableName}')->addColumn('{$column->getName()}', '{$typeName}', {$optionsStr});\n";
            }
        }

        // Columns to drop
        foreach ($fromTable->getColumns() as $column) {
            if (!$toTable->hasColumn($column->getName())) {
                $code .= "        \$schema->getTable('{$tableName}')->dropColumn('{$column->getName()}');\n";
            }
        }

        return $code;
    }

    /**
     * Get column options as array.
     */
    protected function GetColumnOptions(Column $column): array
    {
        $options = [];

        if ($column->getLength() !== null) {
            $options['length'] = $column->getLength();
        }

        if (!$column->getNotnull()) {
            $options['notnull'] = false;
        }

        if ($column->getDefault() !== null) {
            $options['default'] = $column->getDefault();
        }

        if ($column->getAutoincrement()) {
            $options['autoincrement'] = true;
        }

        if ($column->getUnsigned()) {
            $options['unsigned'] = true;
        }

        return $options;
    }

    /**
     * Generate a version string.
     */
    protected function GenerateVersion(string $name): string
    {
        $timestamp = date('YmdHis');
        $safeName = preg_replace('/[^a-zA-Z0-9]/', '', $name);
        return "Version{$timestamp}_{$safeName}";
    }

    /**
     * Generate the migration file template.
     */
    protected function GenerateMigrationTemplate(string $className, string $upCode, string $downCode): string
    {
        $namespace = $this->migrationsNamespace;
        $upCode = $upCode ?: "        // Add your schema changes here";
        $downCode = $downCode ?: "        // Revert schema changes here";

        return <<<PHP
<?php

declare(strict_types=1);

namespace {$namespace};

use Doctrine\DBAL\Schema\Schema;
use VCL\Database\Migration\AbstractMigration;

/**
 * Auto-generated Migration
 */
class {$className} extends AbstractMigration
{
    public function GetDescription(): string
    {
        return '';
    }

    public function Up(Schema \$schema): void
    {
{$upCode}
    }

    public function Down(Schema \$schema): void
    {
{$downCode}
    }
}

PHP;
    }

    /**
     * Write migration file to disk.
     */
    protected function WriteFile(string $version, string $content): string
    {
        if (!is_dir($this->migrationsPath)) {
            mkdir($this->migrationsPath, 0755, true);
        }

        $filePath = $this->migrationsPath . '/' . $version . '.php';

        if (file_put_contents($filePath, $content) === false) {
            throw new MigrationException("Failed to write migration file: {$filePath}");
        }

        return $filePath;
    }

    /**
     * Convert array to PHP code string.
     */
    protected function ArrayToCode(array $array): string
    {
        if (empty($array)) {
            return '[]';
        }

        $parts = [];
        foreach ($array as $key => $value) {
            if (is_bool($value)) {
                $valueStr = $value ? 'true' : 'false';
            } elseif (is_string($value)) {
                $valueStr = "'" . addslashes($value) . "'";
            } elseif (is_null($value)) {
                $valueStr = 'null';
            } else {
                $valueStr = (string)$value;
            }

            $parts[] = "'{$key}' => {$valueStr}";
        }

        return '[' . implode(', ', $parts) . ']';
    }

    /**
     * Convert string to PascalCase.
     */
    protected function ToPascalCase(string $string): string
    {
        return str_replace(' ', '', ucwords(str_replace(['_', '-'], ' ', $string)));
    }
}
